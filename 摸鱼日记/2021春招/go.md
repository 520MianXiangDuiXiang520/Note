# Go 面试准备

## 3.9

### go 的调度

GMP 模型：

* G：goroutine 是调度的基本单位，通过 `go` 创建
* M：machine 是一个操作系统的内核级线程
* P：processor 是一个虚拟的处理器，每个 M 对应一个 P

M 和 P 一一对应，最大数量由全局变量 `GOMAXPROCS` 决定，默认为处理器核心数，每个 P 都有一个 **运行队列**， 当某一个 goroutine 被创建时，他就会被加入到某个 P 的运行队列中，P 会将自己队列中的 G 取出来放到 M 上执行。

当所有 P 的运行对垒都满了后，新创建的 goroutine 会被放在 **全局队列** 中。

如果 P 的运行队列中没有 goroutine 了，他就会从全局队列中取，如果全局队列中也是空的，他回去从别的 P 的运行队列中 **窃取**

#### 阻塞场景

1. 如果 goroutine 因为 原子、互斥量或通道操作调用导致阻塞，P 会把这个 goroutine 切换出去，执行别的 G
2. 如果由于网络请求或 IO 操作导致阻塞，这个 G 会被移动到网络轮询器，P 调度其他 G 执行，Net Poller 通过 IO 多路复用等机制监听 IO 事件是否就绪，IO 完成后，这个 G 会被重新放回队列中，等待下一次被调度。
3. 由于某些系统调用导致 M 阻塞：调度器会将 P 和这个被阻塞的 M 分离，然后引入新的 M 执行 P 队列中的 goroutine, 当系统调用结束后，这个 G 会被重新加入到执行队列，而刚被阻塞的 M 则会被放入缓存，用来处理以后相同的情况
4. G 执行 sleep 导致 M 被阻塞：Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以强占的标识符，别的 Goroutine 就可以抢先进来执行。只要下次这个 Goroutine 进行函数调用，那么就会被强占，同时也会保护现场，然后重新放入 P 的本地队列里面等待下次执行。

### go struct 能不能比较

### go defer

### select 作用

### context 用在哪

### client 如何实现长连接

### 主协程如何等其余协程完再操作

### slice,len,cap, 共享，扩容

### map 如何顺序读取

### 如何实现一个 set

### 如何实现一个消息队列