# 字符串

## 不可变的String

String是一种不可变类型，所有对字符串的修改实质上都是返回了一个新串。

## 重载“+”与StringBuilder

Java不允许程序员重载运算符，但Java本身为String重载了两个运算符`+`和`+=`,这也是Java中唯二被重载的运算符。他们可以很方便的做字符串的拼接，但Java私下了为此做了很多优化，通过对class文件反编译，可以看见字符串是怎么通过`+`拼接在一起的。

```java
package Note.strings;

public class Concatenation {
    public static void main(String[] args) {
        String mango = "mango";
        String s = "abc" + mango + "def" + 47;
        System.out.println(s);
    }
}
```

使用`javap -c Concatenation`反编译

```txt
警告: 二进制文件Concatenation包含Note.strings.Concatenation
Compiled from "Concatenation.java"
public class Note.strings.Concatenation {
  public Note.strings.Concatenation();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // String mango 把常量池中的项压入栈
       2: astore_1                          // 将引用类型或returnAddress类型值存入局部变量1
       3: new           #3                  // class java/lang/StringBuilder
       6: dup                               // 复制栈顶部一个字长内容
       7: invokespecial #4                  // Method java/lang/StringBuilder."<init>":()V 根据编译时类型来调用实例方法
      10: ldc           #5                  // String abc 把常量池中的项压入栈
      12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      15: aload_1                           // 从局部变量1中装载引用类型值
      16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      19: ldc           #7                  // String def
      21: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      24: bipush        47                  // 将一个8位带符号整数压入栈
      26: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      29: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      32: astore_2                          // 将引用类型或returnAddress类型值存入局部变量2
      33: getstatic     #10                 // Field java/lang/System.out:Ljava/io/PrintStream; 从类中获取静态字段
      36: aload_2                           // 从局部变量2中装载引用类型值
      37: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      40: return
}

```

通过反编译，上面Concatenation中main里的执行过程如下：

1. 把常量池中的项（mango这个字符串）压入栈
2. 把`"mango"`存入局部变量1 mango
3. 创建了一个StringBuilder对象
4. 把`"abc"`这个串压入栈
5. 调用StringBuilder的append方法【此时StringBuilder中是`"abc"`】
6. 从局部变量1中装载引用类型值(mango)
7. 在调用append()【此时StringBuilder中是`"abcmango"`】
8. 把def压入栈
9. 再调用append()【此时StringBuilder中是`"abcmangodef"`】
10. 把47压入栈
11. 调用append()【此时StringBuilder中是`"abcmangodef47"`】
12. 调用toString(),返回`"abcmangodef47"`

Java自动调用了StringBuilder，因为它更加高效，然后通过四次调用append方法，最后才返回这个新的字符串。

如果滥用Java的string对象，可能导致性能下降：

```java
package Note.strings;

public class WhitherStringBuilder {
    public String implicit(String[] fields) {
        String s = "";
        for(int i = 0;i<fields.length;i++){
            s += fields[i];
        }
        return s;
    }

    public String explicit(String[] fields){
        StringBuffer stringBuffer = new StringBuffer();
        for(int i = 0;i<fields.length;i++){
            stringBuffer.append(fields[i]);
        }
        return stringBuffer.toString();
    }

    public static void main(String[] args) {
        WhitherStringBuilder wsb = new WhitherStringBuilder();
        String [] strings = {"abc", "def", "ghi"};
        wsb.explicit(strings);
        wsb.implicit(strings);
    }
}

```

不同的String处理方法，但返回的结果是一样的，他们的性能相差很大。

反汇编后，只把implicit和explicit的部分拿出来

```txt
 public java.lang.String implicit(java.lang.String[]);
    Code:
       0: ldc           #2                  // String
       2: astore_2
       3: iconst_0
       4: istore_3
       5: iload_3
       6: aload_1
       7: arraylength
       8: if_icmpge     38
      11: new           #3                  // class java/lang/StringBuilder
      14: dup
      15: invokespecial #4                  // Method java/lang/StringBuilder."<init>":()V
      18: aload_2
      19: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      22: aload_1
      23: iload_3
      24: aaload
      25: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      28: invokevirtual #6                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      31: astore_2
      32: iinc          3, 1
      35: goto          5
      38: aload_2
      39: areturn

```

过程：

1. 将`""`压入栈
2. 将`""`存入局部变量astore_2
3. 将一个int型的常量0压入栈
4. 将0存入局部变量istore_3
5. 装载局部int变量3的值（0）
6. 装在引用类型局部变量1的值（形参，那个数组）
7. 求数组长度（3）
8. 判断（i）如果大于等于（fields.length）就跳转到38行
9. 创建一个新的StringBuilder对象
10. 复制栈顶的一个字做备份([为什么new 之后要使用dup](#https://blog.csdn.net/aigoogle/article/details/23762903))
11. 调用StringBuilder构造器
12. 装载引用2的值（`""`）
13. 调用append方法
14. 装载引用1的值（fields）
15. 装载整型引用3的值（0）
16. 从数组（fields）中装载引用类型（获取数组中第i个对象）
17. 调用append方法【此时为：abc】
18. 调用toString方法
19. 将toString的返回值存入局部变量2
20. 整型局部变量3加1
21. 跳转到第5行
22. 装载引用2
23. 返回引用

第8行到第35行构成一个循环，这个代码的问题在于每次循环都会创建一个StringBuilder对象，虽然表面看不见，但这样会大大降低程序效率，所以有循环过程的String处理应该直接使用StringBuilder，而不应该过分依赖编译器，就像explicit方法一样。

```txt
 public java.lang.String explicit(java.lang.String[]);
    Code:
       0: new           #7                  // class java/lang/StringBuffer
       3: dup
       4: invokespecial #8                  // Method java/lang/StringBuffer."<init>":()V
       7: astore_2
       8: iconst_0
       9: istore_3
      10: iload_3
      11: aload_1
      12: arraylength
      13: if_icmpge     30
      16: aload_2
      17: aload_1
      18: iload_3
      19: aaload
      20: invokevirtual #9                  // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
      23: pop
      24: iinc          3, 1
      27: goto          10
      30: aload_2
      31: invokevirtual #10                 // Method java/lang/StringBuffer.toString:()Ljava/lang/String;
      34: areturn

```

explicit反编译后，13到27行构成循环，而StringBuffer对象在第0行只创建一次，所以，如果`toString()`中包含循环，那么最好自己创建一个StringBuilder对象，用它来构造最终的结果。

## 无意识递归

## String常用操作

## 格式化输出

## 正则表达式

字符

|   |   |
|---|---|
|`B`|指定字符B|
|`\xhh`|十六进制为0xhh的字符|
|`\uhhhh`|十六进制为0xhhhh的Unicode字符|
|`\t`|制表符|
|`\n`|换行|
|`\r`|回车|
|`\f`|换页|
|`\e`|转义（Escape）|

字符类

|    |    |
|----|----|
|`.`|任意字符|
|`[abc]`|包含abc的任意字符|
|`[^abc]`|除abc外的任意字符|
|`[a-z]`|范围|
|`&&`|交|
|`\s`|空白符|
|`\S`|非空白符|
|`\d`|数字|
|`\D`|非数字|
|`\w`|单词|
|`\W`|非单词|

逻辑操作符

|   |    |
|---|----|
|XY|Y跟在X后面|
|`X|Y`|X或Y|
|`(X)`|捕获组，可以在表达式中使用`\i`引用第i个捕获组|

边界匹配符

|   |   |
|---|---|
|`^`|一行起始|
|`$`|一行结束|
|`\b`|词边界|
|`\B`|非词边界|
|`\G`|前一个匹配的结束|

### 量词

量词描述了一个模式吸收输入文本的方式

* 贪婪型： 默认量词，会为所有可能的模式发现尽可能多的匹配
* 懒惰型（勉强型）：用`?`表示，匹配满足模式尽可能少的字符
* 占有型：Java独有，用来防止表达式失控

|贪婪型|懒惰型|占有型|匹配|
|-----|------|-----|----|
|`X?`|`X??`|`X?+`|一个或零个|
|`X*`|`X*?`|`X*+`|零个或多个|
|`X+`|`X+?`|`X++`|一个或多个|
|`X{n}`|`X{n}?`|`X{n}+`|恰好n个|
|`X{n,}`|`X{n,}?`|`X{n,}+`|至少n个|
|`X{n,m}`|`X{n,m}?`|`X{n,m}+`|至少n次，之多m次|

### Pattern和Matcher

`java.util.regex`包中的`static Pattern.compile()`方法可以编译正则表达式，然后将你要检索的字符串传入`Pattern`对象的`matcher()`方法，`matcher()`会生成一个`Matcher`对象，他有很多有用的功能。

|方法|作用|返回值|
|----|---|------|
|`replaceAll()`|将所匹配到的部分替换成传入的参数|`String`|
|`split()`|从匹配的地方分割字符串，返回分割后的String数组|`String[]`|
|`matches()`|判断传入的字符串是否符合正则模式（完全符合）|`boolean`|
|`find()`|像迭代器一样向前遍历字符串，可以传入一个整数（字符串中字符的位置）作为搜索起点|`boolean`|
|`start()`|返回先前匹配的起始位置的索引(匹配失败抛出`IllrgalStateException`异常)|`int`|
|`end()`|返回最后匹配的字符的索引加一的值(匹配失败抛出`IllrgalStateException`异常)|`int`|

### 组

组是用括号划分的正则表达式，可以根据组的编号来引用某个组，组号0表示整个表达式，组号1表示第一对被括号括起来的组。

## 扫描输入