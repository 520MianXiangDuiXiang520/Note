# 字符串

## 不可变的String

## 重载“+”与StringBuilder

```java
package Note.strings;

public class Concatenation {
    public static void main(String[] args) {
        String mango = "mango";
        String s = "abc" + mango + "def" + 47;
        System.out.println(s);
    }
}
```

使用`javap -c Concatenation`反编译

```txt
警告: 二进制文件Concatenation包含Note.strings.Concatenation
Compiled from "Concatenation.java"
public class Note.strings.Concatenation {
  public Note.strings.Concatenation();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // String mango 把常量池中的项压入栈
       2: astore_1                          // 将引用类型或returnAddress类型值存入局部变量1
       3: new           #3                  // class java/lang/StringBuilder
       6: dup                               // 复制栈顶部一个字长内容
       7: invokespecial #4                  // Method java/lang/StringBuilder."<init>":()V 根据编译时类型来调用实例方法
      10: ldc           #5                  // String abc 把常量池中的项压入栈
      12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      15: aload_1                           // 从局部变量1中装载引用类型值
      16: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      19: ldc           #7                  // String def
      21: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      24: bipush        47                  // 将一个8位带符号整数压入栈
      26: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      29: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      32: astore_2                          // 将引用类型或returnAddress类型值存入局部变量2
      33: getstatic     #10                 // Field java/lang/System.out:Ljava/io/PrintStream; 从类中获取静态字段
      36: aload_2                           // 从局部变量2中装载引用类型值
      37: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      40: return
}

```

通过反编译，上面Concatenation中main里的执行过程如下：

1. 把常量池中的项（mango这个字符串）压入栈
2. 把`"mango"`存入局部变量1 mango
3. 创建了一个StringBuilder对象
4. 把`"abc"`这个串压入栈
5. 调用StringBuilder的append方法【此时StringBuilder中是`"abc"`】
6. 从局部变量1中装载引用类型值(mango)
7. 在调用append()【此时StringBuilder中是`"abcmango"`】
8. 把def压入栈
9. 再调用append()【此时StringBuilder中是`"abcmangodef"`】
10. 把47压入栈
11. 调用append()【此时StringBuilder中是`"abcmangodef47"`】
12. 调用toString(),返回`"abcmangodef47"`

```java
package Note.strings;

public class WhitherStringBuilder {
    public String implicit(String[] fields) {
        String s = "";
        for(int i = 0;i<fields.length;i++){
            s += fields[i];
        }
        return s;
    }

    public String explicit(String[] fields){
        StringBuffer stringBuffer = new StringBuffer();
        for(int i = 0;i<fields.length;i++){
            stringBuffer.append(fields[i]);
        }
        return stringBuffer.toString();
    }

    public static void main(String[] args) {
        WhitherStringBuilder wsb = new WhitherStringBuilder();
        String [] strings = {"abc", "def", "ghi"};
        wsb.explicit(strings);
        wsb.implicit(strings);
    }
}

```

反汇编后，只把implicit和explicit的部分拿出来

```txt
 public java.lang.String implicit(java.lang.String[]);
    Code:
       0: ldc           #2                  // String
       2: astore_2
       3: iconst_0
       4: istore_3
       5: iload_3
       6: aload_1
       7: arraylength
       8: if_icmpge     38
      11: new           #3                  // class java/lang/StringBuilder
      14: dup
      15: invokespecial #4                  // Method java/lang/StringBuilder."<init>":()V
      18: aload_2
      19: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      22: aload_1
      23: iload_3
      24: aaload
      25: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      28: invokevirtual #6                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      31: astore_2
      32: iinc          3, 1
      35: goto          5
      38: aload_2
      39: areturn

```

过程：

1. 将`""`压入栈
2. 将`""`存入局部变量astore_2
3. 将一个int型的常量0压入栈
4. 将0存入局部变量istore_3
5. 装载局部int变量3的值（0）
6. 装在引用类型局部变量1的值（形参，那个数组）
7. 求数组长度（3）
8. 判断（i）如果大于等于（fields.length）就跳转到38行
9. 创建一个新的StringBuilder对象
10. 复制栈顶的一个字做备份([为什么new 之后要使用dup](#https://blog.csdn.net/aigoogle/article/details/23762903))
11. 调用StringBuilder构造器
12. 装载引用2的值（`""`）
13. 调用append方法
14. 装载引用1的值（fields）
15. 装载整型引用3的值（0）
16. 从数组（fields）中装载引用类型（获取数组中第i个对象）
17. 调用append方法【此时为：abc】
18. 调用toString方法
19. 将toString的返回值存入局部变量2
20. 整型局部变量3加1
21. 跳转到第5行
22. 装载引用2
23. 返回引用

第8行到第35行构成一个循环，这个代码的问题在于每次循环都会创建一个StringBuilder对象，虽然表面看不见，但这样会大大降低程序效率，所以有循环过程的String处理应该直接使用StringBuilder，而不应该过分依赖编译器，就像explicit方法一样。

```txt
 public java.lang.String explicit(java.lang.String[]);
    Code:
       0: new           #7                  // class java/lang/StringBuffer
       3: dup
       4: invokespecial #8                  // Method java/lang/StringBuffer."<init>":()V
       7: astore_2
       8: iconst_0
       9: istore_3
      10: iload_3
      11: aload_1
      12: arraylength
      13: if_icmpge     30
      16: aload_2
      17: aload_1
      18: iload_3
      19: aaload
      20: invokevirtual #9                  // Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
      23: pop
      24: iinc          3, 1
      27: goto          10
      30: aload_2
      31: invokevirtual #10                 // Method java/lang/StringBuffer.toString:()Ljava/lang/String;
      34: areturn

```

explicit反编译后，13到27行构成循环，而StringBuffer对象在第0行只创建一次

## 无意识递归

## String常用操作

## 格式化输出

## 正则表达式

## 扫描输入