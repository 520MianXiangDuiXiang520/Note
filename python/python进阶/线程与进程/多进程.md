# 多进程

多进程比起多线程更加稳定，如果一个进程死掉了，并不会影响别的进程，但如果一个线程挂了，整个程序就挂了，当然，主进程要是挂了也没办法，python中multiprocessing用来支持多线程编程，他提供了Process、Queue、Pipe、Lock等组件

## 进程的创建与管理

Process类用来创建和管理进程，另外，可以使用Pool进行进程并发操作，调用Process()时必须放在`if __name__ == '__main__':`下面，否则在python3下会报错，在python2下会一直创建进程，直到电脑资源耗尽，这个的原因emmmmmm，首先`if __name__ == '__main__':`是python的每一个模块都肯定有一个`__name__`属性，对他程序自己来说，他的`__name__`就是`__main__`而从外部导入的模块代码运行时就不是了，如果不加这一句，外部导入模块语句就会被重复执行，进程就会被一直创建，python3中对进程创建进程有限制，所以会报错。

### Process类

#### Process类的属性和方法

```python
class Process():
    name: str
    daemon: bool
    pid: Optional[int]
    exitcode: Optional[int]
    authkey: bytes
    sentinel: int
    # TODO: set type of group to None

    def __init__(self,
                    group: Any = ...,
                    target: Optional[Callable] = ...,
                    name: Optional[str] = ...,
                    args: Iterable[Any] = ...,
                    kwargs: Mapping[Any, Any] = ...,
                    *,
                    daemon: Optional[bool] = ...) -> None: ...

    def start(self) -> None: ...
    def run(self) -> None: ...
    def terminate(self) -> None: ...
    if sys.version_info >= (3, 7):
    def kill(self) -> None: ...
    def close(self) -> None: ...
    def is_alive(self) -> bool: ...
    def join(self, timeout: Optional[float] = ...) -> None: ...
```

属性介绍：
看源码有六个属性，name就是进程名，daemon是是否是守护进程，pid是进程对应的pid，exitcode好像是与进程运行有关的，进程正在运行他的值是None，要是进程被某个信号结束，这个属性可以显示哪个信号，后面那个authkey更不懂了，字面意思就是自动生成的一个key，他与网络连接底层进程间通信的安全有关，是一个32位字符串，sentinel，哨兵，似乎与定时发送消息有关...

参数介绍：

* group: 未使用，None
* target:调用对象，与线程中的一样
* name：进程名，不指定会自动创建
* args：多值元组
* kwargs:多值字典
* daemon：为True时创建守护进程

方法介绍：

* start：启动进程
* run：启动进程，这是真的启动，start也是调用子进程的run方法才启动的，用类创建进程时就要重写run方法
* terminate：强制终止这个进程，不做清理，如果该进程创建了子进程，子进程就会变成僵尸进程，如果这个进程还有一个锁没有释放，就会导致死锁
* kill：直接杀死进程
* close：关闭进程池，关闭之后就不允许别的Process加入了
* is_alive:判断进程还活着没
* join：阻塞主进程等待该进程结束

#### 创建子进程的两种方法

##### 1. 使用函数创建

```python
# 使用函数创建进程
from multiprocessing import Process
import time
import os

def demo(x,y):
    StartTime=time.time()
    print('%s start ...'%os.getpid())
    print(x+y)
    time.sleep(2)
    print('%s end runs %0.2f s'%(os.getpid(),(time.time()-StartTime)))

if __name__ == '__main__':
    s=Process(target=demo,args=(1,2))
    d=Process(target=demo,args=(3,4))
    s.start()
    d.start()
    print('main')
```

结果

```txt
main
28956 start ...
3
21140 start ...
7
28956 end runs 2.00 s
21140 end runs 2.00 s

```

##### 2. 使用类创建

使用类创建就是重写Process类，必须继承Process类

```python
# 使用类创建进程
from multiprocessing import Process
import time
import os

class MyProcess(Process):
'''重写process类'''
    def __init__(self,x,y):
        super().__init__()
        self.x=x
        self.y=y
    def run(self):
        StartTime=time.time()
        print('%s start'%self.name)
        print(self.x+self.y)
        time.sleep(2)
        print('%s end runs %0.2f s' % (self.name, (time.time() - StartTime)))

if __name__ == '__main__':
    q=MyProcess(1,2)
    d=MyProcess(3,4)
    q.start()
    d.start()

```

运行结果

```txt
MyProcess-1 start
3
MyProcess-2 start
7
MyProcess-1 end runs 2.00 s
MyProcess-2 end runs 2.00 s
```

#### 僵尸进程和孤儿进程

这两个一般针对Linux来说，Windows进程间父子关系很弱，进程自生自灭，不存在所谓僵尸进程

##### 1. 僵尸进程

由于父进程和主进程是异步的，所以父进程不会知道主进程会在什么时候结束，因此，为了让子进程结束后让父进程知道，子进程结束后会保留一部分系统资源如pid,运行时间，退出状态等，等父进程通过wait()或者waitpid()系统调用取得这些信息时，这部分资源才会被释放，但如果父进程一直未调用wait()或者waitpid()，那这些资源就一直不会被释放，比如pid，pid的数量是有限的，如果僵尸进程过多，就会导致pid不足而无法创建新进程，所以僵尸进程是有害的。

```python
# 僵尸进程
from multiprocessing import Process
import time
import os

def demo():
    StartTime=time.time()
    print('%d process start,father is %d  time is %.2f'%(os.getpid(),os.getppid(),StartTime))
    time.sleep(1)
    print('%d process end father is %d time is %.2f'%(os.getpid(),os.getppid(),time.time()))

if __name__ == '__main__':
    p=Process(target=demo)
    print('father process is %d'%os.getpid())
    p.start()
    time.sleep(10000)
    print('father process is %d' % os.getpid())
```

运行之后，子进程1s结束，主进程延时10000，子进程就会变成僵尸进程，通过`ps aux|grep Z`(使用通道查看所有与Z有关的系统进程)可以发现这个僵尸进程(第一个)

```shell
junbao@ubuntu:~$ ps aux |grep Z
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
junbao    24234  0.0  0.0      0     0 pts/0    Z+   22:12   0:00 [python3] <defunct>
junbao    24259  0.0  0.0  21536  1104 pts/1    S+   22:13   0:00 grep --color=auto Z
```

处理僵尸进程的办法一是杀死父进程，父进程结束后僵尸进程就会变成孤儿进程，由init收养后释放资源。二是使用signal(SIGCHLD, SIG_IGN)处理僵尸进程，父进程在接收到子进程退出的信号后，直接将其忽略掉，类似于父进程先退出。

##### 2. 孤儿进程

如果父进程终止，而由父进程创建的一个或多个子进程还在执行的话，这一个或多个子进程就会成为孤儿进程，成为孤儿进程后，善后工作（wait()或者waitpid()等）就会由init接管，init进程是内核启动的第一个进程，pid=1，由0号进程idle创建。应为有人善后，所以孤儿进程是无害的。

进程并行

守护进程

## 进程间通信

## 进程同步