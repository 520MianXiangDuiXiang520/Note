# Redis 持久化

内存中的数据在断电之后会丢失，如果想要长期保存这些数据，就需要把内存数据定期备份在硬盘；Redis中的所有数据就都是在内存，为了保存这些数据，Redis提供了“持久化”机制，来将内存中的数据以文件形式保存在磁盘上，当Redis重启时，就会先从这些文件加载备份数据；Redis的持久化有两种一种是RDB，另一种是AOF。

<!-- more -->

## 1.RDB

这是Redis持久化机制默认的方式，也就是“保存快照”的方式，“快照”是内存中数据的二进制序列化形式，在存储上非常紧凑，持久化时，Redis把快照保存到硬盘中，后缀为`.RDB`;当Redis重启时，就会加载`.RDB`文件，读取文件内容，还原数据。

`.rdb`文件中存储的数据是二进制形式的，这样的好处在于占用存储空间更小。

### 1.1. 这个持久化文件在哪

配置文件中有`dir`配置， 默认是`./`,这个配置项就指示了Redis运行过程中产生的文件的保存目录，默认是启动目录，持久化文件（无论是RDB还是AOF都一样）当然也是保存在这个目录下的。

### 1.2 什么时候触发rbd持久化

1. 在执行 `SHUTDOWN`时， 如果没有开启aof，就会触发rdb机制
2. 当满足配置文件中save 配置项的条件时

```conf
# 900s内有1次修改
save 900 1
# 300s内有10次修改
save 300 10
# 60s内有10000次修改
save 60 10000

# 如果要禁用持久化，设置 save ""
```

3. 执行save或bgsave命令时,这两个命令都是用来手动触发rdb持久化的。
4. 执行flushall命令， 空的，无意义

#### 1.2.1 save和bgsave的区别

他们的主要区别是save是同步的，而bgsave是异步的；

##### save

当客户端向服务器发送SAVE命令时，Redis主进程会把所有内存的数据保存到一个临时的rdb文件中，等到持久化结束，再用这个临时文件替换原来的持久化文件（如果存在的话），由于Redis单进程的特点，主进程在进行持久化时无法接收和处理客户端的请求，客户端会被阻塞，直到主进程持久化结束。

##### bgsave

bgsave是异步的，当服务器接受到BGSAVE命令时，会单独创建一个与当前进程一模一样的子进程来进行持久化，这个子进程的所有数据（数据变量，环境变量， 程序计数器等）都和原进程一模一样，然后子进程会同样将数据写入一个临时文件中，待持久化结束，在用这个临时文件替换上次持久化好的文件。

由于bgsave命令是由子进程完成的，所以在执行bgsave命令期间，redis任然可以接收和处理客户端其他请求，但主进程创建子进程时，Redis任然会被阻塞，应为创建子进程，也会消耗额外的内存

配置

1. `dir dbfilename`  dbfile 存放目录，aof文件也会存放在该目录下，如果不指定，从哪启动就存放在那
2. `appendonly no`: 是否开启AOF持久化，默认不开启（RDB默认开启） 

## 2. AOF（appendonly）

原理是将Redis的操作日志以追加的方式保存到`.aof`文件中（查询的语句不保存），保存的是字符串。

在配置文件之，修改`appendonly`为`yes`启用AOF，生成的AOF文件的文件名通过`appendfilename` 指定

## 2.1 有了RDB为什么还要有AOF？

1. RDB耗时，耗性能
   这里主要体现在：
   1. 持久化内存中的数据，该操作的时间复杂度是 $O(n)$ 
   2. 其次把数据保存到文件中，这也会消耗CPU资源
   3. 使用bgsave命令fork子进程也会消耗内存
   4. RDB是达到触发条件一次性写入的，如果数据非常多，占用的内存页会非常大，保存到硬盘的过程也会消耗很多IO
2. RDB过程不可控， 容易丢失数据
   自动创建RDB文件的过程中，如果未达到触发条件，突然Redis停止服务，那上一次持久化之后的数据就会丢失

### 2.2 AOF的安全性问题

虽然AOF是将所有修改操作都记录在AOF文件中，但它也并不是完全安全的，在Linux中，因为CPU和IO的速度不匹配，为了提高效率，你要往硬盘写入文件，他并不是直接就写道硬盘中了，而是会先写入到缓冲区，等到缓冲区满了或者用户主动调用fsync调用和fdatasync调用时，再写入到磁盘。所以对Redis来说，越早将命令写入，那么发生意外时丢失的数据就越少。

### 2.3 触发机制

AOF提供了三种策略用来权衡安全性和性能，具体配置是

```conf
# appendfsync always
appendfsync everysec
# appendfsync no
```

* always: 就是每次修改，都把修改命令刷新到磁盘缓冲区并执行调用，写入到硬盘，安全性最高，不会丢失已经成功执行的数据，但由于Redis支持每秒写入百万数据，这样的策略效率不是很高
* everysec：AOF的默认策略，每秒将修改刷新到缓冲区并写入到硬盘，即使Redis意外停机，也只会丢失一秒内的数据
* no: Redis不会主动调用fdatasync,由操作系统决定什么时候将缓冲区内容写入硬盘，发生意外时，丢失数据的数量是无法确定的，几乎不用。

### 2.4 AOF 重写

如果我们执行了一下指令

```redis
set a 1
set a 2
set a 3
```

那在一般情况下，这三条指令都会被保存在AOF文件中，但事实上a最终的值是3，前两条记录完全是无意义的，AOF重写机制就是为了解决这样的问题，他会删除无用记录，来达到AOF文件瘦身的效果。

#### 2.4.1 AOF重写的触发机制

应为在持久化某一条命令时，并不能确定它是不是有用的，所以AOF重写只会在特定时刻进行。

1. 服务端接受到`BGREWRITEAOF`命令时，类似于BGSAVE命令，Redis主进程会fork一个子进程，由子进程去完成AOF重写操作
2. 达到配置文件中`auto-aof-rewrite-percentage`或`auto-aof-rewrite-min-size`配置的条件时

```conf
# 增长率，如果AOF的文件大小大于上次AOF重写后大小的 x% 后，执行AOF重写
auto-aof-rewrite-percentage 100

# 如果AOF文件大小大于这设定的值时，执行AOF重写
auto-aof-rewrite-min-size 64mb
```

> AOF重写是一个复杂的过程，他是将Redis中的数据进行一次回溯，以此生产一个新的AOF文件的过程，并不是修改原来的AOF文件，频繁的进行AOF重写可能导致性能大幅下降，所以auto-aof-rewrite-min-size不应该设置太小。

#### 2.4.2 混合持久化机制

在Redis4.0之后的版本中，设置`aof-use-rdb-preamble`为`yes`开启混合持久化机制。

混合持久化是通过bgrewriteaof完成的，fork出来的子进程将内存中的数据以RDB大方式写入aof文件，然后磁盘缓冲区中怎家的命令会以AOF的方式写入，这样的结果是aof文件前半段是ROF格式的二进制数据，后半段是AOF格式的文本数据，这样的好处是aof文件中，绝大部分内容是RDB格式的，占用内存小，加载速度快，而增量数据也用AOF格式保存了，数据安全性也有了提高，缺点就是兼容性差，应为4.0之前没有这个机制。


## 3. RDB和AOF的选择