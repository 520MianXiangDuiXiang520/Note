# KMP

KMP 是字符串匹配中常常会用到的一种很高效的算法，但他相对不太好理解，是我上学时最恐惧的算法之一。

我觉得任何一个计算机问题都可以使用暴力解决，而要理解一个更高效算法，最重要的是要知道它比起暴力优化了哪写部分，换言之，我们要知道暴力算法中有哪些步骤是不需要的。

所以先来看字符串匹配使用暴力如何解决(我们的目的是从一个长串 `long` 中尝试找到一个短串 `short` 第一次出现的位置)：

```go
func Snail(long, short string) int {
	if len(short) > len(long) {
		return -1
	}

	for i := 0; i < len(long) - len(short); i++ {
		j := 0
		for j < len(short) {
			if long[i + j] != short[j] {
				break
			}
			j ++
		}
		if j == len(short){
			return i
		}
	}

	return -1
}
```

这个版本确实很暴力，它遍历长串并判断以长串中的每一个字符为首是否能与短串匹配，容易看出时间复杂度是 $O(m*n)$

让我们看看暴力匹配有哪些可以优化的点：

假设有以下数据：

```py
long =  "abcdefghi"
short = "zbe"
```

由于第一个字符就不匹配，所以即便使用暴力匹配，它也可以在 $O(m)$ (`m = len(long)`) 的时间复杂度内完成，几乎没有可以优化的空间，由此其实就可以看出暴力之所以效率低的原因是前面已经有很长一串匹配成功了，突然出现了一个匹配不成功的，你就要重新从头开始匹配，就像下面这种情况：

```py
long =  "abcdefghijklmnopqrstabcdefghijklmnopqrst"
short = "abcdefghijklmnopqrz"
```

所以就需要尽可能避免这种情况，观察上面这种情况，我们发现长串和短串在第 $18$ 位发现不相等，这意味着长传和短串的前 18 位都是相等的，按暴力匹配，这时就要将长串的第二位与短串的第一位再开始比较，但由于这 18 位字符互不相等，所以这 18 位中的第二位一定不等于这 18 位中的第一位，话有点绕，但逻辑很容易理解，因为有两个条件：

1. 18 位每个字符互不相等
2. 长串和字串的这 18 位是相等的

意识到这一点很重要，因为根据这个规律，我们可以跳过与长串的这 18 位进行比较（其实是 17 位，第一位已经不可避免地比较过了）。

但这个规律建立地前提是已经完成匹配的串（记为串P）中的每个字符互不相等，那再看另一种极端的情况：

```py
long =  "aaaaaaaaaaaaaaaaaaaaaaaaazaaaaaaaaaaaaa"
short = "aaaaaaaaaaaaaaaaaaz"
```

很显然，如果串 P 的每一个字符完全一样，我们就只能按暴力的老样子遍历了因为你不确定长串在 19 位后的哪个地方会出现一个 `z`

通过这两个极端，你应该能发现能不能跳和能跳多少位其实和长串无关，那我们聚焦短串，想想第一个能跳那么多而第二个不能跳的原因是什么？

你应该能发现第二个不能跳的原因是串 P 存在相同的前后缀

> 这里说与他自己可能容易引起歧义，而之所以这样说是因为我们直到匹配到第 x 位(这里就是 19 位)才发现不匹配了，所以前面的是完全匹配的，因此长串和短串的这前 x 位我们就把他看成一个串了
>
> 这里我觉得还是引入前缀和后缀解释比较方便，顾名思义一个串的前缀就是它前面的一部分，后缀就是它后面的一部分，比如串 `abcd`, 前缀就是 `{a, ab, abc}` 后缀就是 `bcd cd d`

因为存在相同的前后缀，所以如果你还像第一个例子那样全部跳过就是有问题的，看下面这个更普遍的例子就很好理解了：

```py
long =  "abcdeabcdeabcdeab"
short = "abcdeabk"
```

第一轮比较在第 7 位发现不匹配，但由于前 6 位 `abcdeab` 存在相同的前后缀 `ab` 所以从第 5 位开始能匹配成功的概率是有的，你也只能跳过 `bcde` 这 4 位。

这是一个很精妙的性值，也是 KMP 的核心思想，如果你还不能理解，与第一个例子对比看看？

因此我们能够得到，匹配中能跳多少位取决于已经完成匹配的串的最长公共前后缀，前面已经说过，能不能跳和能跳多少只取决于短串，因此，我们就可以根据短串求出一个表，记录当匹配完成到短串的第 k 位时，短串的前 k 位的最长公共前后缀是多少，我们计这个表为 next 表，下面给出上面三个短串的 next 表：

| idx  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| v    | a    | b    | c    | d    | e    | f    | g    | h    | i    | j    | k    | l    | m    | n    | o    | p    | q    | r    | z    |
| next | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

上面是第一个例子的 next 表，由于这个短串完全没有相同的字符，所以不管匹配到了哪一位，都无法找到公共的前后缀


| idx  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| v    | a    | a    | a    | a    | a    | a    | a    | a    | a    | a    | a    | a    | a    | a    | a    | a    | a    | a    | z    |
| next | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 0    |

这是第二个例子的 next 表，由于它完全相同，所以匹配失败的位置越靠后公共前后缀就越长, 注意最后一个 z 

| idx  | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| v    | a    | b    | c    | d    | e    | a    | b    | k    |
| next | 0    | 0    | 0    | 0    | 0    | 1    | 2    | 0    |

有了 next 数组就可以改写我们的代码了：

```go
func KMP(long, short string, next []int) int {
	if len(short) > len(long) {
		return -1
	}

	for i := 0; i <= len(long) - len(short);  {
		fmt.Println(i)
		j := 0
		for j < len(short) {
			if long[i + j] != short[j] {
				break
			}
			j ++
		}
		if j == len(short){
			return i
		}
		if j == 0 {
			i ++
		} else {
			i += j - next[j - 1]
		}
	}
	return -1
}
```

代码整体结构没有发生任何变化，只不过长串遍历的步幅不再是 1 了，这意味着在大部分情况下他更快了。

需要注意 next 表中第 j 列的语义是当短串的前 j 个字符已经匹配成功时（包括第 j 个）这 j 个字符的最长公共前后缀，所以当 `j == 0` 时，肯定没有公共前后缀，就按暴力那样不跳就好（参考短串长度为 1 的情况）而在此之后都可以跳 `j - next[j - 1]` 位，参考下图：

![](https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/16403697505111640369750481.png)

下一轮比较时，长串会从紫色箭头处开始与短串进行比较，我们同时画出了暴力匹配的比较位置，这样使用 next 数组的优势就显而易见了。

而接下来的问题就是如何求 next 数组了：

我们知道 `next[i]=k` 表示在短串 P 中前 i 个字符的前 k 位和后 k 位相等，从一个更普遍的情况来看，假设我们已经求得了 next 数组的前 $i - 1$ 位，看下面这个例子：

| idx  | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| val  | d    | e    | d    | d    | e    | d    | ？   |
|next    |0|0|1|1|2|3||

假设有短串 P `dedded？` 已经求得了其前 6 个的 next 值，把当前要求的字符位置记为制作 `this` 把目前已知最长前缀的下一个字符位置记为 `pre`, 如果 `P[this] == P[pre]` 则说明可以拓展最长前后缀，看上面的例子，已知 `next[5] == 3` 说明 `dedded` 的公共最长前后缀长度是 3 即 `ded` 这时求 `next[6]` 则 `this = 6, pre = 3` 如果第六位恰好是 `d` 则可以拓展公共前后缀为 `dedd` 从而 `next[6] = 4` 



如果不巧 `P[6] == e` 显然无法继续拓展，你需要记得，我们现在是在根据后缀找前缀，this 指针指向的一定是后缀，所以你要找一个前缀，并且要找一个尽可能长的前缀，巧的是



