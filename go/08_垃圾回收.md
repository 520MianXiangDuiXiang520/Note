# Go 垃圾回收-三色扫描+混合屏障

垃圾回收器是 Go 内存管理组件中的核心部分，用户程序通过内存分配器申请内存资源，而垃圾回收器负责程序中的垃圾对象，释放内存，Go 语言垃圾回收器从最开始的标记清除，到后来的三色扫描+混合屏障，逐渐减少甚至取消了 STW 对用户程序的影响，提高了性能。

<!-- more -->

## 标记清除

标记清除（Mark-Sweep）是一种常见的垃圾回收算法，在 Python 等高级语言中经常可以见到它的身影，Go 在 1.3 版本之前也使用了标记清除技术。

顾名思义，标记清除一般被分为两个阶段：

* 标记（Mark）：从根对象出发，标记所有可达的对象，如果某个对象从根对象不可达，说明它不会被用户程序使用，是垃圾。
* 清除（Sweep）：保留所有被标记的对象，删除所有没被标记的。

标记清除的优点是实现简单，缺点是一旦发生 GC，就需要遍历所有对象，并且为了确保在 GC 过程中变量引用关系不发生变化， 需要暂停整个用户程序，这个过程叫做 STW（Stop The World），如果程序很庞大，STW 的时间可能到达几百毫秒甚至几秒，这在一些对实时性要求高的系统中是不可接受的，所以基于弱代假说，标记清除一般会配合**分代回收**技术使用，经过几轮 GC， 如果一个对象一直存活，那他在接下来也会大概率存活，所以把它划分到 “老年代”，而把新创建的将对象划分到“年轻代”，年轻代的 GC 频率高于老年代，以此通过减少每次 GC 遍历的对象量来减少 STW 的时间，但哪怕引入分代回收，STW 也是依然存在不可避免的，为了进一步减少 STW的时间，Go 在 1.3 之后就采用了三色标记的技术。

根对象一般是栈中的对象和一些全局变量.

## 三色标记

三色标记可以看作是标记清除的升级版，在这个算法中，堆中的所有对象被标记为黑白灰三种颜色，一开始，所有的对象都是白色的，然后从根节点开始遍历（只遍历一层），将遍历到的节点标记为灰色，然后遍历所有的灰色节点，将这些灰色节点引用的白色节点全部标记为灰色，原来的灰色节点标记为黑色，循环上一步，直到没有灰色节点为止，所有的白色节点就是垃圾，可以通过下图理解这个过程：

1. 对象引用关系如下图且一开始时，所有对象均为白色：

   ![](https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1612435000209-1612435000155.png)

2. 遍历一步根对象，将所有遍历到的对象（A， C， E）标记为灰色:

   ![](https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1612435029856-1612435029843.png)

3. 遍历一步所有灰色对象，将遍历到的对象全部标记为灰色，原来的灰色对象标记为黑色。

   ![](https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1612435090596-1612435090570.png)

4. 重复2， 3 步，直到没有灰色对象为止

   ![](https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1612435197901-1612435197899.png)

5. 回收所有白色对象。

   ![](https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1612435259641-1612435259638.png)

   

使用三色标记在 GC 期间还是需要 STW，比如看下面的无 STW 下执行三色标记的场景：

比如GC执行到下面这一步时，D 删除了对 G 的引用，而 E 有引用了 G：

| Before                                                       | After                                                        |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![](https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1612435536595-1612435536583.png) | ![](https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1612435788208-1612435788205.png) |

这时如果进行下一步，因为 D 已经删除了与 G 的引用，而 E 已经被标记为黑色，所以 G 会被错误的当成垃圾回收掉，这会造成严重的**悬挂指针**问题，这就需要屏障技术。

## 屏障技术

> 内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。

简单来说，屏障技术就是在编译期在用户代码中插入一些代码，以保证程序正确运行，如果想要三色标记回收的正确性，一般只需要满足两个不变性中的其一即可：

1. 强三色不变性：不允许黑色对象指向白色对象
2. 弱三色不变性：黑色对象要想指向白色对象，这个白色对象必须有一个灰色对象经过若干白色对象可达。

其中，强三色不变性可以通过插入写屏障实现，弱三色不变性可以通过删除写屏障实现。

### 插入写屏障

插入写屏障由 Dijkstra 在 1978 年提出，如下图一，假如在 GC 期间，我们将 E 指向 G，也就是执行类似 `*E = G` 的代码时，就会触发插入写屏障，写屏障会将 G 的颜色变为灰色，这样 G 在这一轮就不会被回收了，如下图二:

| 图一                                                         | 图二                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![](https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1612435788208-1612435788205.png) | ![](https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1612699302151-1612699302137.png) |

这是写屏障的伪代码：

```python
writePointer(slot, ptr):
    shade(ptr)
    *slot = ptr
```

`shade` 会在黑色对象引用白色对象时，将白色对象标记为灰色。

插入写屏障是一种相对保守的屏障策略，它将所有可能存活的对象都标记为灰色，比如 E 指向 G 后又删除了这个引用，那 G 就是一个真垃圾了，但这时 G 已经被标记为灰色，所以它只有等待下一轮 GC 才能被回收。

由于栈上的对象会被作为根对象，所以如果想要使用插入写屏障保证 GC 安全，要么在栈上复制时也开启写屏障，要么在扫描栈对象时 STW，前者会大大增加写入指针时的开销，后者需要暂时 STW，所以在 Go 1.7  之前，堆对象使用插入写屏障扫描完后，会通过 STW暂停保护栈，再重新扫描一遍栈空间；在 1.7 之后，Go 团队通过使用混合屏障技术取消了扫描栈时的 STW 过程。

### 删除写屏障

> Yuasa 在 1990 年的论文 Real-time garbage collection on general-purpose machines 中提出了删除写屏障，因为一旦该写屏障开始工作，它会保证开启写屏障时堆上所有对象的可达，所以也被称作快照垃圾收集（Snapshot GC）

删除写屏障保证了弱三色不变性，在开始 GC 之前，通过 STW  对整个根做一次起始快照,使所有根对象被标记为黑色, 下一级对象被标记为灰色,这样堆中所有在用对象都会被灰色保护起来。当用户删除从黑色或灰色对象到白色对象的引用时，写屏障会捕捉这一行为，并将白色对象标记为灰色，如下图一，灰色对象 D 删除了对白色对象 G 的引用，触发写屏障，G 就会被标记为灰色，如下图二：

| 图一                                                         | 图二                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![](https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1612435788208-1612435788205.png) | ![](https://cdn.jsdelivr.net/gh/520MianXiangDuiXiang520/cdn@master/img/1612700426241-1612700426179.png) |

删除写屏障在 GC 期间新 New  出来的对象都会被标记为黑色。

之所以要在 GC 开始时扫描所有 Goroutine 栈,也是因为屏障技术不能应用在栈上,

删除写屏障是一种比较悲观的算法，他认为所有被黑色或灰色删除的对象都是应该存活的，所以它的精度较插入写较低,并且在 GC 开始时,也需要 STW 扫描所有 Goroutine 栈, 以保证堆中在用的对象都处于灰色.

### 混合写屏障

为了减少插入写屏障 STW 的时间, 从 1.8 开始, Go  将插入写屏障和删除写屏障结合成混合写屏障,混合写屏障的规则如下:

1. GC 开始将栈上的对象全部扫描并标记为黑色
2. GC 期间，任何在栈上创建的新对象，均为黑色。
3. 被删除的对象标记为灰色。
4. 被添加的对象标记为灰色。



## 参考

[Go语言设计与实现-垃圾收集器](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector)

[golang 垃圾回收（二）屏障技术 2020/6/3 10:44](https://blog.csdn.net/qiya2007/article/details/107291497)

[Golang三色标记+混合写屏障GC模式全分析](https://www.kancloud.cn/aceld/golang/1958308)