# Go GPM 并发模型

## goroutine 的优势

都说 Go 是为并发而生的，但 Go 的并发优势究竟体现在哪呢？

在批处理的时代，CPU 取指执行，遇到 IO 等耗时操作，只能等待，但在 CPU 的时间观里， IO 是在是太慢了，CPU利用率几乎为零，后来有了多道程序的概念，每一个被加载到内存中的程序被称之为一个进程，使用进程控制块 PCB 描述，CPU 以进程为单位分配和调度资源，遇到 IO 就切换出去执行别的进程，为了保证多个进程一起操作内存不会造成混乱，我们又内存映射的概念，给每个进程分配一个内存映射表，进程操纵虚拟内存，再通过映射表映射到真实的物理内存上，但是，切换进程时，就要连着虚拟内存空间一起切换，这会导致进程切换代价很大，后来，在进程的基础上，又提出了线程的概念，线程依附于进程，多个线程一起使用进程的虚拟内存，所以进行线程切换时，只需要切换线程自己的栈和相关寄存器就可以了，这其实是用户级线程，用户级线程完全在用户态调度，操作系统感知不到它的存在，在进行系统调用时，必须从用户态切换到内核态，进程中的一个线程进行系统调用，同一进程下的所有线程都必须等待他完成，这又会造成 CPU 资源的浪费，加上多核处理器的发展，我们希望一个程序能充分利用多核优势，所以就有了核心级线程，他直接被操作系统所支持，他解决了用户级线程的一些问题，但截至现在，CPU 的性能越来越高，核心级线程的切换还是代价太大了，我们希望用更小的操作单元来执行并发事务，这就是协程。

Golang 中的 Goroutine 就是一种协程，

## GPM

**G**: goroutine,是我们创建的一个协程。

**P**: Processor, 逻辑处理器，对 G 来说，一个 P 就相当于一个 CPU 核心。

**M**: Machine, 是对操作系统线程的抽象，是真正干活的人。