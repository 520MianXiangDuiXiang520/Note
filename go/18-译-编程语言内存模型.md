# 编程语言内存模型

(*[Memory Models](https://research.swtch.com/mm), Part 2*)

Posted on Tuesday, July 6, 2021. [PDF](https://research.swtch.com/plmm.pdf)

编程语言的内存模型回答了并行的程序可以依赖哪些（硬件）行为以便在线程之间共享内存的问题。例如，考虑以下类 c 程序, 其中 x 和 done 都是从零开始的：

```c
// Thread 1           // Thread 2
x = 1;                while(done == 0) { /* loop */ }
done = 1;             print(x);
```

程序尝试将变量 x 的值从线程 1 同步给线程 2，使用变量 done 作为准备好接收消息的信号，如果线程 1 和线程 2 都运行在自己专门的线程上，并且都执行结束，则该程序能保证按预期打印 1 吗？编程语言的内存模型回答了这个问题以及其他类似的问题。

尽管每个编程语言在细节上有所不同，但有一些通用的答案基本能始应现代的多线程程序，包括 C, C++, Go, Java, JavaScript, Rust 和 Swift :

* 首先，如果 x 和 done 是普通变量，那么线程 2 的循环可能永远不会停止。一个常见的编译器优化是在变量第一次使用时将其加载到寄存器中，然后在将来尽可能长时间地来使用该寄存器来访问该变量。如果线程 2 在线程 1 执行之前将 done 复制到寄存器中，它可能会在整个循环中一直使用该寄存器，而不会注意到线程 1 在稍后修改了 done.
* 其次，即便线程 2 地循环停止，即已经观察到 done == 1, 线程 2 任然可以输出 x = 0. 编译器经常根据 优化启发式（optimization heuristics） 甚至是生成代码时遍历哈希表或其他数据结构地形式对程序读写进行重排序。线程 1 编译后的代码可能在 done 赋值之后而不是之前写入 x，而且线程 2 编译后的代码也可可能在循环之前读取 x

考虑到这个程序的缺陷，显而易见的问题是如何修复它。

现代编程语言以原子变量或原子操作的形式提供了一些特殊的功能，以允许程序同步其线程，如果将 `done` 设置为原子变量（或者在支持原子操作的语言中使用原子操作操作它），那么我们的程序将保证正确结束并打印出 1 ，将 `done` 设置为 “原子的” 会产生很多效果：

* 线程 1 编译后的代码必须保证对 `x` 的写完成，并且在写 `done` 之前需要保证 `x` 的写入结果对其他线程可见。
* 线程 2 编译后的代码必须在每次循环时重新读取 `done` 的值。
* 线程 2 编译后的代码必须保证在读 `x` 之前先读 `done`
* 编译后的代码需要做一些必要的事情来组织可能重新导致这些问题的硬件优化。

使 `done` 原子化的最终结果就是程序将按我们预期的样子执行：成功将 x 的值从线程 1 传递到线程 2.

在原来的代码中，经过编译器的代码重排序后，线程 1 可能在线程 2 读取 `x` 的同时修改 `x` 的值，这就是数据竞争(data race) ，在修改后的程序中，原子变量 `done` 用于同步对 `x` 的访问: 现在，线程 1 在写 `x` 的同时线程 2 再读  `x`是不可能的了，该程序就是无数据竞争（data-race-free）的了。通常，现代语言保证无数据竞争的程序总是以顺序一致的方式执行，就像来自不同线程的操作都被安排到单一的处理器上交叉执行，但没进行重新排序一样。这是[硬件内存模型的 DRF-SC 属性](https://research.swtch.com/hwmm#drf)，被应用到了编程语言的上下文中。

顺便一提，这些原子变量或原子操作更恰当的应该被称之为 “同步原子（synchronizing atomic）”，在数据库的意义上，这些操作确实是原子的，允许同时读取和写入，就像按某种顺序顺序运行一样：在使用 atomic 时，普通变量的竞争不再是竞争。但更重要的是 atomic 同步程序的其余部分，这提供了一种消除非原子数据竞争的方法。不过它的标准术语就是普通的 "原子（atomic）" 故本文也这样使用，除非另外说明，你只需要记住，我们在说 “原子（atomic）” 时指的就是 “同步原子（synchronizing atomic）”。

编程语言的内存模型规定了程序员和编译器之间需要约定的确切细节。上述概括的一般特征基本上适用于所有现代编程语言，但这一点直到最近才趋于相同，在 20 世纪之初，有着更多明显的差异。即使在今天，不同编程语言在二阶逻辑（second-order）问题上依然存在诸多差异，包括：

* 原子变量本身的顺序保证是什么
* 变量是否既可以原子访问，又可以非原子访问
* 除了原子之外是否还有其他的同步机制
* 是否存在不同步的原子操作
* 有数据竞争的程序有什么保证吗

在做一些基本的准备操作后，本文剩余的部分将探讨不同编程语言如何回答这些问题，以及他们解决这些问题的办法。本文同样会介绍在探索路上的那些错误设计，来强调在很大程度上，我们仍然在学习什么是管用的，什么是不管用的。

## 硬件、Litmus Tests、Happens Before 和 DRF-SC

在我们详细了解特定语言的细节之前，让我们先对硬件内存模型做一个简要的总结。

不同的 CPU 架构允许对不同的指令进行重排序，因此在多核处理器上并行运行的代码根据体系结构到的不同可能会产生不同的执行结果。黄金法则是顺序一致性，他要求任何（并发的）执行其最终表现结果都表现为程序只是以某种顺序在单个处理器上交错执行。这个模型对开发人员来说更容易理解，但现在还没有主要的体系结构去支持它，因为较弱的保证往往能提供更好的性能。

其实很难对不同的内存模型进行全面的比较，但是 Litmus 测试可以帮助你只专注于特定的测试用例，如果两个内存模型针对给定的 Litmus 表现出不同的行为，那这证明他们是不同的，这至少能帮我们看到在这一个测试用例中，一个内存模型是否比另一个更强或更弱。例如这是我们之前检查程序的一条 Litmus 测试：

```c
Litmus Test: Message Passing
Can this program see r1 = 1, r2 = 0?

// Thread 1           // Thread 2
x = 1                 r1 = y
y = 1                 r2 = x
On sequentially consistent hardware: no.
On x86 (or other TSO): no.
On ARM/POWER: yes!
In any modern compiled language using ordinary variables: yes!
```

如在前一篇文章中一样，我们假设每个实例中共享变量的初始值都是零，`rn` 表示私有存储，比如寄存器或函数局部变量, 其他名称如 x 和 y 是不同的共享(全局)变量。我们询问在执行结束后，寄存器是否可以是特定的值。在回答硬件的 Litmus 测试时，我们假设没有编译器对线程中的代码进行重排序：列表中的指令将直接翻译成汇编指令在处理器上执行。

结果 `r1 = 1, r2 = 0` 代表原始程序（上面第一个程序）的线程 2 结束了 “循环” （这里 `done` 变成了 `y`）然后输出 0，程序在任何顺序一致的机器上交错执行都无法重复该结果，对于汇编语言版本，尽管由于处理器本身的指令重排，在 x86 上打印出 0 也是不可能的；但在 ARM 和 POWER 等更宽松的的架构上打印出 0 就是可能的。在现代编程语言中，由于编译器的指令重排，使得无论底层硬件是什么，这个结果都有可能出现。

